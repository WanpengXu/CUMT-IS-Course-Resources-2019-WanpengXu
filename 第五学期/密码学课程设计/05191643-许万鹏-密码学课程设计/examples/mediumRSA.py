# 小明文攻击
# 适用情况：明文m很小，公钥e也很小，一般为3。
# 于是 m^e=k*n+c中的k值较小。
# 从0开始穷举k，对每一次k*n+c开e次方，直到得到整数结果，整数结果即为明文
import gmpy2
from Crypto.Util.number import long_to_bytes


def small_msg(e, n, c):
    for k in range(200000000):
        if gmpy2.iroot(k * n + c, e)[1]:
            return gmpy2.iroot(k * n + c, e)[0]
    return False


e = 3  # 公钥
# openssl读出的16进制的n
hex_n = "B0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929"
n = int(hex_n, 16)

with open('flag.enc', 'rb') as f:
    cipher = f.read()
    cipher = int.from_bytes(cipher, byteorder="big")

msg = small_msg(3, n, cipher)

print(long_to_bytes(msg))
